\section{Use Cases in Internet of Things}

Deploying virtual-kubelet to an IoT device is a double-edged sword. On the one hand, it easily migrates development effort of Kubernetes communication to IoT. You get security and interoperability out of the box. For every possible state of your end device, there is a predefined Kubernetes description that matches with it. That allows solutions for cloud environments to co-operate with end devices, such as the \textit{Node Watcher} program explained before. On the other hand, Kubernetes ecosystem is not build for resource-constrained devices. The communication protocol between kubelets and Kubernetes master is HTTPS. While it's secure, it's more resource hungry than other popular IoT messaging systems such as MQTT. As discussed above, projects like FLEDGE overcome this problem by deploying virtual-kubelet to the cloud and using MQTT to connect to devices. An e-mail exchange with one of the FLEDGE authors revealed that they are migrating their codebase to deploy virtual-kubelet on the end device. It's up to the developers to decide which one is more suitable for their system. If they are using large clusters with weak end devices such as microcontrollers, it's better to deploy virtual-kubelet to the cloud and deploy a more lightweight agent to end device. If they have relatively powerful devices, such as Raspberry Pi, it's completely possible to deploy virtual-kubelet to the them.

To test unikernel technology on IoT, a demo program is created to read values from sensors. A python script reads sensor data and writes it to file, then the running unikernel application reads that file to get the actual data. Python file updates 3 files with 3 different sensor data, and the name of the sensor data to be read can be given to the unikernel when starting. Those parameter is specified on the yaml file that deploys that unikernel to the device. In the future, the python script will be obsolete and unikernel can read sensor value directly from the input buffer. This was not implemented in this demo, because it requires to write a OCaml driver for Raspberry Pi sensor connections, which is out of scope. A special Kubernetes resource, DaemonSet, allows Kubernetes to automatically deploy certain containers to every node. This is used mainly for monitoring or for proxying but for IoT It's a sure way to deploy certain programs to every end device. The user does not have to deal with new deployments when new devices join the cluster. Kubernetes will simply deploy predetermined programs to it by looking at labels the newly added device. Full code of the program can be seen in \ref{fig:ocaml-demo}. That code is accompanied with a config file which determines input arguments and lists dependencies. Total image size is 2.6 MB when compiled.

\begin{code}[htpb]
    \centering
    \begin{tabular}{c}
    \begin{lstlisting}[language=caml,showstringspaces=false,breaklines=true,upquote=true]
        open Lwt.Infix

        module Main (KV: Mirage_kv.RO) (Time: Mirage_time.S) = struct
        
          let start kv _time=
        
            let read_from_file kv filename = (*Filename given as argument*)
                KV.get kv (Mirage_kv.Key.v filename) >|= function
                    | Error e ->
                        Logs.warn (fun f -> f "Cannot find the file %a"
                        KV.pp_error e)
                    | Ok sensor_value ->
                        Logs.info (fun f -> f "Reading from: %s -> %s" filename sensor_value);
            in
                let filename=Key_gen.filename() in
                let rec loop() =
                read_from_file kv filename >>= fun()->
                Time.sleep_ns (Duration.of_sec 2)>>= fun () ->
                loop()
                in 
                loop()
        end
  \end{lstlisting}
  \end{tabular}
  \caption{A MirageOS program}\label{fig:ocaml-demo}
\end{code}