\section{Use Cases in Internet of Things}

Deploying virtual-kubelet to an IoT device is a double-edged sword. On the one hand, it easily migrates development effort of Kubernetes communication to IoT. You get security and interoperability out of the box. For every possible state of your end device, there is a predefined Kubernetes description that matches with it. That allows solutions for cloud environments to co-operate with end devices, such as the \textit{Node Watcher} program explained before. On the other hand, Kubernetes ecosystem is not build for resource-constrained devices. The communication protocol between kubelets and Kubernetes master is HTTPS. While it's secure, it's more resource hungry than other popular IoT messaging systems such as MQTT. As discussed above, projects like FLEDGE overcome this problem by deploying virtual-kubelet to the cloud and using MQTT to connect to devices. An e-mail exchange with one of the FLEDGE authors revealed that they are migrating their codebase to deploy virtual-kubelet on the end device. It's up to the developers to decide which one is more suitable for their system. If they are using large clusters with weak end devices such as microcontrollers, it's better to deploy virtual-kubelet to the cloud and deploy a more lightweight agent to end device. If they have relatively powerful devices, such as Raspberry Pi, it makes more sense to deploy virtual-kubelet to the them.

Additional to the Raspberry Pi example in the \hyperref[chapter:implementation]{implementation} section, another example was developed to show the interaction between unikernels and sensors. A python script was created to read sensor data from multiple sensors and write it to respective files. Unikernels can be programmed to read sensor data directly from GPIO pins, but implementation of a driver for MirageOS is out of scope for this example. The unikernels in the example read sensor data from files instead. The name of the respective sensor file is given in the deployment specification of the unikernel and it's then passed as an environment variable to the running application. Full code for the application can be seen in \ref{fig:ocaml-demo}. This code is accompanied with a config file which determines names of input arguments and lists dependencies. It becomes obsolete once the application is compiled and the binary can be distributed standalone. It takes 2.6 MB when compiled for unix. Complete deployment specification for a unikernel that reads humidity sensor can be found in \ref{fig:unikernel-dep}.

\begin{code}[htpb]
    \centering
    \begin{tabular}{c}
    \begin{lstlisting}[language=caml,showstringspaces=false,breaklines=true,upquote=true]
        open Lwt.Infix

        module Main (KV: Mirage_kv.RO) (Time: Mirage_time.S) = struct
        
          let start kv _time=
        
            let read_from_file kv filename = (*Filename given as argument*)
                KV.get kv (Mirage_kv.Key.v filename) >|= function
                    | Error e ->
                        Logs.warn (fun f -> f "Cannot find the file %a"
                        KV.pp_error e)
                    | Ok sensor_value ->
                        Logs.info (fun f -> f "Reading from: %s -> %s" filename sensor_value);
            in
                let filename=Key_gen.filename() in
                let rec loop() =
                read_from_file kv filename >>= fun()->
                Time.sleep_ns (Duration.of_sec 2)>>= fun () ->
                loop()
                in 
                loop()
        end
  \end{lstlisting}
  \end{tabular}
  \caption{A MirageOS program}\label{fig:ocaml-demo}
\end{code}